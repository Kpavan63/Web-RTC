<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Color-Based Object Detection with OpenCV.js</title>
    <style>
        body {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            font-family: Arial, sans-serif;
            height: 100vh;
            margin: 0;
        }
        #canvasOutput {
            border: 2px solid #4CAF50;
            border-radius: 8px;
            margin-top: 20px;
            width: 100%;
            max-width: 600px;
            height: auto;
        }
        #videoInput {
            display: none; /* Hide the video element */
        }
        .btn {
            padding: 10px 20px;
            margin-top: 10px;
            background-color: #4CAF50;
            color: white;
            border: none;
            cursor: pointer;
            border-radius: 5px;
        }
    </style>
</head>
<body>

<h1>Color-Based Object Detection</h1>
<button class="btn" onclick="toggleCamera()">Switch Camera</button>
<video id="videoInput" autoplay playsinline></video>
<canvas id="canvasOutput"></canvas>

<!-- OpenCV.js Library -->
<script async src="https://docs.opencv.org/4.x/opencv.js" type="text/javascript"></script>

<script>
    let video = document.getElementById('videoInput');
    let canvas = document.getElementById('canvasOutput');
    let ctx = canvas.getContext('2d');
    let useFrontCamera = true;
    let videoStream;

    // Function to start the camera
    async function startCamera() {
        const constraints = {
            video: {
                facingMode: useFrontCamera ? 'user' : 'environment',
                width: { ideal: 1280 },
                height: { ideal: 720 }
            }
        };
        try {
            videoStream = await navigator.mediaDevices.getUserMedia(constraints);
            video.srcObject = videoStream;
            video.play();
            video.onloadedmetadata = () => {
                console.log('Video metadata loaded');
                canvas.width = video.videoWidth;
                canvas.height = video.videoHeight;
                processVideo();
            };
        } catch (error) {
            console.error('Error accessing camera:', error);
            alert('Unable to access the camera. Please check permissions.');
        }
    }

    // Function to toggle between front and back cameras
    function toggleCamera() {
        useFrontCamera = !useFrontCamera;
        if (videoStream) {
            videoStream.getTracks().forEach(track => track.stop()); // Stop previous stream
        }
        startCamera();
    }

    // Function to process video frames for color detection
    function processVideo() {
        const src = new cv.Mat(video.height, video.width, cv.CV_8UC4);
        const dst = new cv.Mat(video.height, video.width, cv.CV_8UC3);
        const cap = new cv.VideoCapture(video);

        function detectColor() {
            cap.read(src);

            // Check if src is empty
            if (src.empty()) {
                console.error('Empty frame received from video capture');
                requestAnimationFrame(detectColor);
                return;
            }

            cv.cvtColor(src, dst, cv.COLOR_RGBA2RGB);

            // Convert to HSV and apply color threshold (example for red color)
            cv.cvtColor(dst, dst, cv.COLOR_RGB2HSV);
            const lower = new cv.Mat(dst.rows, dst.cols, dst.type(), [0, 150, 50, 0]); // Lower red
            const upper = new cv.Mat(dst.rows, dst.cols, dst.type(), [10, 255, 255, 255]); // Upper red
            const mask = new cv.Mat();
            cv.inRange(dst, lower, upper, mask);

            // Find contours of the object
            const contours = new cv.MatVector();
            const hierarchy = new cv.Mat();
            cv.findContours(mask, contours, hierarchy, cv.RETR_EXTERNAL, cv.CHAIN_APPROX_SIMPLE);

            // Draw bounding boxes for each contour found
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            for (let i = 0; i < contours.size(); i++) {
                const rect = cv.boundingRect(contours.get(i));
                ctx.strokeStyle = "#FF0000";
                ctx.lineWidth = 2;
                ctx.strokeRect(rect.x, rect.y, rect.height, rect.height);
                ctx.font = '16px Arial';
                ctx.fillStyle = "#FF0000";
                ctx.fillText('Detected', rect.x, rect.y > 10 ? rect.y - 5 : 10); // Label above the box
            }

            // Clean up
            mask.delete();
            contours.delete();
            hierarchy.delete();
            lower.delete();
            upper.delete();
            requestAnimationFrame(detectColor); // Process next frame
        }

        detectColor(); // Start color detection
    }

    // Initialize OpenCV
    document.addEventListener('DOMContentLoaded', startCamera);
</script>

</body>
</html>
